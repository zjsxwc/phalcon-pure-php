<?php
namespace Phalcon
{

    /**
     * Phalcon\Security
     *
     * This component provides a set of functions to improve the security in Phalcon applications
     *
     * <code>
     * $login = $this->request->getPost('login');
     * $password = $this->request->getPost('password');
     *
     * $user = Users::findFirstByLogin($login);
     * if ($user) {
     * if ($this->security->checkHash($password, $user->password)) {
     * //The password is valid
     * }
     * }
     * </code>
     */
    class Security implements \Phalcon\Di\InjectionAwareInterface
    {

        /**
         *
         * @var \Phalcon\DiInterface
         */
        protected $_dependencyInjector;

        /**
         *
         * @var long
         */
        protected $_workFactor = 8;

        /**
         *
         * @var long
         */
        protected $_numberBytes = 16;

        protected $_csrf;

        /**
         * Set the work factor
         *
         * @param long $workFactor            
         */
        public function setWorkFactor($workFactor)
        {
            $this->_workFactor = $workFactor;
        }

        /**
         *
         * @return long
         */
        public function getWorkFactor()
        {
            return $this->_workFactor;
        }

        /**
         * Sets the dependency injector
         *
         * @param \Phalcon\DiInterface $dependencyInjector            
         */
        public function setDI(\Phalcon\DiInterface $dependencyInjector)
        {
            $this->_dependencyInjector = $dependencyInjector;
        }

        /**
         * Returns the internal dependency injector
         *
         * @return \Phalcon\DiInterface
         */
        public function getDI()
        {
            return $this->_dependencyInjector;
        }

        /**
         * Sets a number of bytes to be generated by the openssl pseudo random generator
         *
         * @param
         *            long randomBytes
         */
        public function setRandomBytes($randomBytes)
        {
            $this->_numberBytes = $randomBytes;
        }

        /**
         * Returns a number of bytes to be generated by the openssl pseudo random generator
         *
         * @return long
         */
        public function getRandomBytes()
        {
            return $this->_numberBytes;
        }

        /**
         * Generate a >22-length pseudo random string to be used as salt for passwords
         *
         * @return string
         */
        public function getSaltBytes()
        {
            while (true) {
                $safeBytes = filter_alphanum(base64_encode(openssl_random_pseudo_bytes($this->_numberBytes)));
                if (strlen($safeBytes) < 22) {
                    continue;
                }
                break;
            }
            return $safeBytes;
        }

        /**
         * Creates a password hash using bcrypt with a pseudo random salt
         *
         * @param
         *            string password
         * @param
         *            int workFactor
         * @return string
         */
        public function hash($password, $workFactor = 0)
        {
            if (! $workFactor) {
                $workFactor = $this->_workFactor;
            }
            
            return crypt($password, '$2a$' . sprintf('%02s', $workFactor . $this->getSaltBytes()));
        }

        /**
         * Checks a plain text password and its hash version to check if the password matches
         *
         * @param
         *            string password
         * @param
         *            string passwordHash
         * @param
         *            int maxPasswordLength
         * @return boolean
         */
        public function checkHash($password, $passwordHash, $maxPassLength = 0)
        {
            if ($maxPassLength) {
                if ($maxPassLength > 0 && strlen($password) > $maxPassLength) {
                    return false;
                }
            }
            
            $cryptedHash = crypt($password, $passwordHash);
            $cryptedLength = strlen($cryptedHash);
            $passwordLength = strlen($passwordHash);
            
            $cryptedHash .= $passwordHash;
            $sum = $cryptedLength - $passwordLength;
            for ($i = 0; $i < $passwordLength; ++ $i) {
                $ch = $passwordHash[$i];
                $sum = $sum | ($cryptedHash[$i] ^ $ch);
            }
            
            return 0 === $sum;
        }

        /**
         * Checks if a password hash is a valid bcrypt's hash
         *
         * @param
         *            string password
         * @param
         *            string passwordHash
         * @return boolean
         */
        public function isLegacyHash($password, $passwordHash)
        {
            return starts_with($passwordHash, '$2a$');
        }

        /**
         * Generates a pseudo random token key to be used as input's name in a CSRF check
         *
         * @param
         *            int numberBytes
         * @return string
         */
        public function getTokenKey($numberBytes = null)
        {
            if (! $numberBytes) {
                $numberBytes = 12;
            }
            
            $safeBytes = filter_alphanum(base64_encode(openssl_random_pseudo_bytes($numberBytes)));
            $this->_dependencyInjector->getShared('session')->set('$PHALCON/CSRF/KEY$', $safeBytes);
            return $safeBytes;
        }

        /**
         * Generates a pseudo random token value to be used as input's value in a CSRF check
         *
         * @param
         *            int numberBytes
         * @return string
         */
        public function getToken($numberBytes = null)
        {
            if (! $numberBytes) {
                $numberBytes = 12;
            }
            
            $token = filter_alphanum(base64_encode(openssl_random_pseudo_bytes($numberBytes)));
            
            $this->_dependencyInjector->getShared('session')->set('$PHALCON/CSRF$', $token);
            
            return $token;
        }

        /**
         * Check if the CSRF token sent in the request is the same that the current in session
         *
         * @param
         *            string tokenKey
         * @param
         *            string tokenValue
         * @return boolean
         */
        public function checkToken($tokenKey = null, $tokenValue = null)
        {
            if (! is_object($this->_dependencyInjector)) {
                throw new Exception("A dependency injection container is required to access the 'session' service");
            }
            
            $session = $this->_dependencyInjector->getShared('session');
            
            if (! $tokenKey) {
                $tokenKey = $session->get('$PHALCON/CSRF/KEY$');
            }
            
            if (! $tokenValue) {
                $request = $this->_dependencyInjector->getShared('request');
                
                /**
                 * We always check if the value is correct in post
                 */
                $token = $request->getPost($tokenKey);
            } else {
                $token = $tokenValue;
            }
            
            /**
             * The value is the same?
             */
            return $token == $session->get('$PHALCON/CSRF$');
        }

        /**
         * Returns the value of the CSRF token in session
         *
         * @return string
         */
        public function getSessionToken()
        {
            if (! is_object($this->_dependencyInjector)) {
                throw new Exception("A dependency injection container is required to access the 'session' service");
            }
            
            return $this->_dependencyInjector->getShared('session')->get('$PHALCON/CSRF$');
        }

        /**
         * string \Phalcon\Security::computeHmac(string $data, string $key, string $algo, bool $raw = false)
         *
         *
         * @param
         *            string data
         * @param
         *            string key
         * @param
         *            string algo
         * @param
         *            boolean raw
         */
        public function computeHmac($data, $key, $algo, $raw = null)
        {
            return hash_hmac($algo, $data, $key, $raw);
        }
    }
}
