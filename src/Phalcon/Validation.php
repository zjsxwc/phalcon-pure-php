<?php
namespace Phalcon
{

    use Phalcon\Di\Injectable;
    use Phalcon\Validation\Exception;
    use Phalcon\Validation\MessageInterface;
    use Phalcon\Validation\Message\Group;
    use Phalcon\Validation\ValidatorInterface;

    /**
     * \Phalcon\Validation
     *
     * Allows to validate data using custom or built-in validators
     */
    class Validation extends \Phalcon\Di\Injectable implements \Phalcon\Events\EventsAwareInterface, \Phalcon\Di\InjectionAwareInterface
    {

        protected $_data;

        protected $_entity;

        protected $_validators;

        protected $_filters;

        /**
         *
         * @var \Phalcon\Validation\Message\Group
         */
        protected $_messages;

        protected $_defaultMessages;

        protected $_labels;

        protected $_values;

        public function setValidators($validators)
        {
            $this->_validators = $validators;
        }

        /**
         * \Phalcon\Validation constructor
         *
         * @param
         *            array validators
         */
        public function __construct($validators = null)
        {
            if (! is_array($validators)) {
                throw new Exception('Validators must be an array');
            }
            $this->_validators = $validators;
            $this->setDefaultMessages();
            
            if (method_exists($this, 'initialize')) {
                $this->{'initialize'}();
            }
        }

        /**
         * Validate a set of data according to a set of rules
         *
         * @param
         *            array|object data
         * @param
         *            object entity
         * @return \Phalcon\Validation\Message\Group
         */
        public function validate($data = null, $entity = null)
        {
            $validators = $this->_validators;
            if (! is_array($validators)) {
                throw new Exception('There are no validators to validate');
            }
            /**
             * Clear pre-calculated values
             */
            $this->_values = null;
            
            /**
             * Implicitly creates a Phalcon\Validation\Message\Group object
             */
            $messages = new Group();
            
            /**
             * Validation classes can implement the 'beforeValidation' callback
             */
            if (method_exists($this, 'beforeValidation')) {
                $status = $this->{'beforeValidation'}($data, $entity, $messages);
                if ($status === false) {
                    return $status;
                }
            }
            
            $this->_messages = $messages;
            
            if (is_array($data) || is_object($data)) {
                $this->_data = $data;
            }
            
            foreach ($validators as $scope) {
                if (! is_array($scope)) {
                    throw new Exception("The validator scope is not valid");
                }
                
                list ($field, $validator) = $scope;
                
                if (! is_object($validator)) {
                    throw new Exception("One of the validators is not valid");
                }
                
                /**
                 * Check if the validation must be canceled if this validator fails
                 */
                if ($validator->validate($this, $field) === false) {
                    if ($validator->getOption('cancelOnFail')) {
                        break;
                    }
                }
            }
            
            /**
             * Get the messages generated by the validators
             */
            $messages = $this->_messages;
            if (method_exists($this, 'afterValidation')) {
                $this->{'afterValidation'}($data, $entity, $messages);
            }
            
            return $messages;
        }

        /**
         * Adds a validator to a field
         *
         * @param
         *            string field
         * @param
         *            \Phalcon\Validation\ValidatorInterface validator
         * @return \Phalcon\Validation
         */
        public function add($field, \Phalcon\Validation\ValidatorInterface $validator)
        {
            $this->_validators[] = array(
                $field,
                $validator
            );
            return $this;
        }

        /**
         * Alias of `add` method
         *
         * @param
         *            string field
         * @param
         *            \Phalcon\Validation\ValidatorInterface validator
         * @return \Phalcon\Validation
         */
        public function rule($field, \Phalcon\Validation\ValidatorInterface $validator)
        {
            return $this->add($field, $validator);
        }

        /**
         * Adds the validators to a field
         *
         * @param
         *            string field
         * @param
         *            array validators
         * @return \Phalcon\Validation
         */
        public function rules($field, $validators)
        {
            foreach ($validators as $validator) {
                if ($validator instanceof ValidatorInterface) {
                    $this->_validators[] = array(
                        $field,
                        $validator
                    );
                }
            }
        }

        /**
         * Adds filters to the field
         *
         * @param
         *            string field
         * @param
         *            array|string field
         * @return \Phalcon\Validation
         */
        public function setFilters($field, $filters)
        {
            $this->_filters[$field] = $filters;
            return $this;
        }

        /**
         * Returns all the filters or a specific one
         *
         * @param
         *            string field
         * @return mixed
         */
        public function getFilters($field = null)
        {
            if (is_string($field)) {
                return isset($this->_filters[$field]) ? $this->_filters[$field] : null;
            }
            return $this->_filters;
        }

        /**
         * Returns the validators added to the validation
         *
         * @return array
         */
        public function getValidators()
        {
            return $this->_validators;
        }

        /**
         * Returns the bound entity
         *
         * @return object
         */
        public function getEntity()
        {
            return $this->_entity;
        }

        /**
         * Adds default messages to validators
         *
         * @param
         *            array messages
         * @return array
         */
        public function setDefaultMessages($messages = null)
        {
            if ($messages === null) {
                $messages = array();
            }
            
            if (! is_array($messages)) {
                throw new Exception("Messages must be an array");
            }
            
            $defaultMessages = array(
                "Alnum" => "Field :field must contain only letters and numbers",
                "Alpha" => "Field :field must contain only letters",
                "Between" => "Field :field must be within the range of :min to :max",
                "Confirmation" => "Field :field must be the same as :with",
                "Digit" => "Field :field must be numeric",
                "Email" => "Field :field must be an email address",
                "ExclusionIn" => "Field :field must not be a part of list: :domain",
                "FileEmpty" => "Field :field must not be empty",
                "FileIniSize" => "File :field exceeds the maximum file size",
                "FileMaxResolution" => "File :field must not exceed :max resolution",
                "FileMinResolution" => "File :field must be at least :min resolution",
                "FileSize" => "File :field exceeds the size of :max",
                "FileType" => "File :field must be of type: :types",
                "FileValid" => "Field :field is not valid",
                "Identical" => "Field :field does not have the expected value",
                "InclusionIn" => "Field :field must be a part of list: :domain",
                "Numericality" => "Field :field does not have a valid numeric format",
                "PresenceOf" => "Field :field is required",
                "Regex" => "Field :field does not match the required format",
                "TooLong" => "Field :field must not exceed :max characters long",
                "TooShort" => "Field :field must be at least :min characters long",
                "Uniqueness" => "Field :field must be unique",
                "Url" => "Field :field must be a url"
            );
            
            $this->_defaultMessages = array_merge($defaultMessages, $messages);
            return $this->_defaultMessages;
        }

        /**
         * Get default message for validator type
         *
         * @param
         *            string type
         * @return string
         */
        public function getDefaultMessage($type)
        {
            return $this->_defaultMessages[$type];
        }

        /**
         * Returns the registered validators
         *
         * @return \Phalcon\Validation\Message\Group
         */
        public function getMessages()
        {
            return $this->_messages;
        }

        /**
         * Adds labels for fields
         *
         * @param
         *            array labels
         */
        public function setLabels($labels)
        {
            $this->_labels = $labels;
        }

        /**
         * Get label for field
         *
         * @param
         *            string field
         * @return string
         */
        public function getLabel($field)
        {
            if (is_array($this->_labels) && isset($this->_labels[$field])) {
                return $this->_labels[$field];
            }
            return $field;
        }

        /**
         * Appends a message to the messages list
         *
         * @param
         *            \Phalcon\Validation\MessageInterface message
         * @return \Phalcon\Validation
         */
        public function appendMessage(\Phalcon\Validation\MessageInterface $message)
        {
            $this->_messages->appendMessage($message);
            return $this;
        }

        /**
         * Assigns the data to an entity
         * The entity is used to obtain the validation values
         *
         * @param
         *            string entity
         * @param
         *            string data
         * @return \Phalcon\Validation
         */
        public function bind($entity, $data)
        {
            if (! is_object($entity)) {
                throw new Exception("Entity must be an object");
            }
            
            if (! is_array($data) && ! is_object($data)) {
                throw new Exception("Data to validate must be an array or object");
            }
            
            $this->_entity = $entity;
            $this->_data = $data;
            
            return $this;
        }

        /**
         * Gets the a value to validate in the array/object data source
         *
         * @param
         *            string field
         * @return mixed
         */
        public function getValue($field)
        {
            if (is_object($this->_entity)) {
                $method = 'get' . $field;
                if (method_exists($this->_entity, $method)) {
                    $value = $this->_entity->{$method}();
                } else {
                    if (method_exists($this->_entity, 'readAttribute')) {
                        $value = $this->_entity->readAttribute($field);
                    } else {
                        $value = isset($this->_entity->{$field}) ? $this->_entity->{$field} : null;
                    }
                }
                
                return $value;
            }
            
            if (! is_array($this->_data) && ! is_object($this->_data)) {
                throw new Exception("There is no data to validate");
            }
            
            /**
             * Check if there is a calculated value
             */
            if (isset($this->_values[$field])) {
                return $this->_values[$field];
            }
            
            $value = null;
            if (is_array($this->_data) && isset($this->_data[$field])) {
                $value = $this->_data[$field];
            } elseif (is_object($this->_data) && isset($this->_data->{$field})) {
                $value = $this->_data->{$field};
            }
            
            if ($value != null) {
                if (is_array($this->_filters) && isset($this->_filters[$field]) && $this->_filters[$field]) {
                    $dependencyInjector = $this->getDI();
                    if (! is_object($dependencyInjector)) {
                        $dependencyInjector = \Phalcon\Di::getDefault();
                        if (! is_object($dependencyInjector)) {
                            throw new Exception("A dependency injector is required to obtain the 'filter' service");
                        }
                    }
                    
                    $filterService = $dependencyInjector->getShared('filter');
                    if (! is_object($filterService)) {
                        throw new Exception("Returned 'filter' service is invalid");
                    }
                    
                    return $filterService->sanitize($value, $this->_filters[$field]);
                }
                
                /**
                 * Cache the calculated value
                 */
                $this->_values[$field] = $value;
                return $value;
            }
            
            return null;
        }
    }
}
